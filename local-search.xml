<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于hash的CDC</title>
    <link href="/2022/12/02/%E5%9F%BA%E4%BA%8Ehash%E7%9A%84CDC/"/>
    <url>/2022/12/02/%E5%9F%BA%E4%BA%8Ehash%E7%9A%84CDC/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>data deduplication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记</title>
    <link href="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>参考教程 <a href="https://web.qianguyihao.com/%E3%80%82">https://web.qianguyihao.com/。</a></p><h1 id="前端工具"><a href="#前端工具" class="headerlink" title="前端工具"></a>前端工具</h1><p>浅浅安装了一些插件，剩下的小技巧以后用到再看，昨晚有点晕字。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h2><p>因为很多浏览器的内核不同，避免因为页面解析导致显示效果不同，从而由W3C组织来指定web相关的标准。</p><ul><li><p>结构标准（html）：网页元素进行整理和分类，从语义的角度描述页面的<strong>结构</strong></p></li><li><p>表现标准（CSS）：<strong>样式</strong>，如颜色大小排版等，虽然这些属性在html中也可以设置，但是最好是独立出来</p></li><li><p>行为标准（js）：网页的<strong>交互和行为</strong></p></li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>浏览器包含两个部分，渲染引擎（浏览器内核）和JS引擎。</p><p>其中浏览器内核用来解析html和css文件，决定浏览器如何显示网页内容以及页面的格式信息。这个是浏览器兼容性问题的根本原因（如Chrome浏览器的内核是Blink，Safari浏览器的内核是Webkit等）。</p><p>JS引擎解析网页中的js代码，处理并运行。实际上是一个解释器，会逐行翻译源码为机器语言，因此js是一种脚本语言。</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/browser_arc.png" class="" title="图片引用方法一"><h2 id="html详解"><a href="#html详解" class="headerlink" title="html详解"></a>html详解</h2><p>超文本标记语言不是一种编程语言，而是一种描述性的标记语言，即有一套标记标签（如&lt;img&gt;、&lt;h1&gt;等），不同的标签给文本加上不同的语义。常见的编程语言在写完代码运行之前还需要经过一步编译，但是标记语言不需要，直接由浏览器解析执行即可。</p><p>目前网页中常用的是xhtml，是严格的、纯净的html。</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/test.png" class="" title="图片引用方法一"><p>创建了一个test.html文件，只需要输入html:5再按tab键就可以自动补全整体框架。页面展示结果如下。</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/res.png" class="" title="图片引用方法一"><p>具体对html语句进行解析。</p><p>第一句&lt;!DOCTYPE …&gt;是文档声明头，浏览器通过这个语句分析文档使用的是哪种html或者xhtml规范。</p><p>&lt;head&gt;标签里面定义了页面的配置，包括字符集（编码与定义不匹配会导致乱码，一般使用utf-8，但如果只显示中文且希望显示速度越快越好，可以用gb2312）、关键词（告诉引擎网页的关键字，可以提高搜索的命中率）、页面描述（可以在搜索的结果页面显示，SEO搜索引擎优化）、页面标题、IE适配、视口（viewport，Web移动端会用到）、iPhone小图标等等。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;3;http://www.baidu.com&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>标签的含义为3秒之后，跳转到百度页面。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;base <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>之后所有的a超链接都以base为基础。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;body <span class="hljs-attribute">link</span>=<span class="hljs-string">&quot;red&quot;</span> <span class="hljs-attribute">alink</span>=<span class="hljs-string">&quot;purple&quot;</span> <span class="hljs-attribute">vlink</span>=<span class="hljs-string">&quot;yellow&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>link定义的颜色是默认的显示颜色，alink定义的颜色是点击且鼠标不松开时显示的颜色，vlink是点击完成之后显示的颜色。</p><p>总的来说，html关心的是标签的嵌套结构，与tab或者换行没有关系。</p><p>html标签是分等级的，所有标签一共分为两种：</p><ul><li><p>文本级标签（如p、span、a、b、i、u、em），标签里面的内容只能够放文字、图片和表单元素（不能放input）</p></li><li><p>容器级标签（div、h、li、dt、dd），可以放任意东西</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">p</span>&gt;<br>This is <span class="hljs-selector-tag">a</span> paragraph<br>&lt;<span class="hljs-selector-tag">h1</span>&gt;This is level <span class="hljs-number">1</span> <span class="hljs-selector-tag">header</span>&lt;/<span class="hljs-selector-tag">h1</span>&gt;<br>&lt;/<span class="hljs-selector-tag">p</span>&gt;<br></code></pre></td></tr></table></figure><p>实际用什么标签不是根据样式决定，而是根据<strong>语义</strong>确定。</p><h3 id="div标签和span标签"><a href="#div标签和span标签" class="headerlink" title="div标签和span标签"></a>div标签和span标签</h3><p>div标签可以把标签中的内容分割为独立区块，必须单独占据一行。span标签和div标签作用一致，但是不需要独占一行。div标签是一个容器级标签，根据上文的介绍，可以放任意的东西（甚至可以放div自己）。而span标签是一个文本级标签，只能放文字、图片和表单。</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/div+span.png" class="" title="图片引用方法一"><p>浏览器的显示效果为：</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/div+span_res.png" class="" title="图片引用方法一"><p>div+css模式就是通过div标签进行布局和分块，用css完成样式。</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>超链接&lt;a&gt;标签一共有三种类型：</p><ul><li>外部链接：直接链接到外部文件，可以是html类型或者http网址</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;another_page.html&quot;</span>&gt;The link <span class="hljs-built_in">to</span> another page&lt;/<span class="hljs-keyword">a</span>&gt;<br>&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;http://www.google.com&quot;</span> target=<span class="hljs-string">&quot;_blank&quot;</span>&gt;The link <span class="hljs-built_in">to</span> google website&lt;/<span class="hljs-keyword">a</span>&gt;<br></code></pre></td></tr></table></figure><p>其中target属性可以用来定义网页的打开方式，比如从同一个页面中打开、在新窗口中打开等。</p><ul><li>锚链接：通过name或者id属性创建一个锚点，然后可以通过锚链接跳转（同一个页面的不同位置或者不同页面的不同位置）</li></ul><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/anchor.png" class="" title="图片引用方法一"><ul><li>邮件链接</li></ul><p>最后需要注意，标签&lt;a&gt;是文本标签，语义小于&lt;p&gt;。</p><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p>无序和有序列表标签都可以嵌套，如下图所示（以ul为例）。</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/embed_list.png" class="" title="图片引用方法一"><p>页面显示结果为</p><img src="/2022/11/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/embed_effect.png" class="" title="图片引用方法一"><p>实际应用于页面的导航栏，或者一个li放很多东西（因为li是一个容器级标签），如搜索出来的结果每一个都是一个li。</p><p>定义列表是标签&lt;dl&gt;，只能包含&lt;dt&gt;（列表项标题）和&lt;dd&gt;（列表项描述）</p><p>实际应用可能是具体的商品分类。</p><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>一个&lt;table&gt;标签中的行是&lt;tr&gt;，每个行的组成单元是&lt;td&gt;。具体一些表格样式的设置可以通过css完成。</p><p>单元格还可以通过colspan和rowspan进行横向或者纵向的合并（但是要把合并的单元格删掉）。</p><p>表格还可以定义&lt;thead&gt; &lt;tbody&gt; &lt;tfoot&gt;三个标签。如果定义了这三个标签，就算实际写的顺序不一样，也会按照head body foot的顺序解析。同时，数据可以一边加载一边显示（正常需要全部加载完才能显示，适合表格内容很多的情况）。</p>]]></content>
    
    
    <categories>
      
      <category>美美自学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P4Spec笔记</title>
    <link href="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>P4（Programming Protocol-independent Packet Processors）是可编程交换机（其实也支持很多不同设备，如NIC、FPGA、路由等）数据平面定义自定义如何处理packet的一种语言。即只实现data plane的功能以及部分与control plane的通信接口。</p><p>下图给出传统固定功能交换机与P4可编程交换机的区别。</p><img src="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/diff.png" class="" title="图片引用方法一"><p>传统交换机中，数据平面的功能由芯片厂商决定，因此控制平面可以修改的数据平面中的表项也是固定的。</p><p>而可编程交换机中，最大的区别在于：</p><ol><li>数据平面的功能不再是固定的，而是通过用户编写的P4程序决定。因此也不会再有内置的可支持网络协议。</li><li>控制平面与数据平面的通信channel与之前相同，但修改的table和有状态的object由p4程序决定。编译器会生成控制平面与数据平面通信的API。</li></ol><p>关键部分：header定义、parser解析序列定义、MATable（构建lookup key，用key查找action，执行对应action）、control flow、external object（如checksum、hash等hard-wired）、用户定义metadata、intrinsic metadata（architecture提供，如报文进入的端口号）。</p><img src="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/workflow.png" class="" title="图片引用方法一"><p>上图为p4的正常工作流程。可以看到，编译完p4程序生成的一个是dataplane runtime（对应代码的configuration），一个是控制平面管理数据平面的API。</p><p>因为p4不支持loop（只有parser可以包含，但实际上编译器还是会展开，并且循环的层数也有限制），因此p4程序的计算复杂度是线性的，某种程度上保证了能够快速处理packet。</p><img src="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/14_16.png" class="" title="图片引用方法一"><p>16相比14的区别在于将很多feature都放到library中（如counter、checksum以及meter）。</p><h1 id="Architecture-Model"><a href="#Architecture-Model" class="headerlink" title="Architecture Model"></a>Architecture Model</h1><p>architecture可以看做是程序和target之间的contract。厂商需要提供一个p4编译器和对应architecture的定义。</p><img src="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/interface.png" class="" title="图片引用方法一"><p>上图是两个可编程组件的interface示例，其中control register&#x2F;signal实际就是architecture定义的intrinsic metadata。同时还可以使用自定义metadata来操作。</p><img src="/2022/11/21/P4Spec%E7%AC%94%E8%AE%B0/extern.png" class="" title="图片引用方法一"><p>还可以调用architecture提供的内置extern object &amp; function，这种extern重点要看的是提供的接口。</p><h1 id="Data-Plane-interface"><a href="#Data-Plane-interface" class="headerlink" title="Data Plane interface"></a>Data Plane interface</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">control MatchActionPipe&lt;H&gt;(in bit&lt;<span class="hljs-number">4</span>&gt; inputPort,<br>                           inout H parsedHeaders,<br>                           out bit&lt;<span class="hljs-number">4</span>&gt; outputPort);<br></code></pre></td></tr></table></figure><p>定义了一个可编程block MatchActionPipe。其中第一个参数是一个4比特的inputPort（输入，无法修改），第二个参数是一个类型为H的object（既是输入也是输出），第三个参数是一个4比特的outputPort（初始值一开始未定义，可以修改）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> Checksum16 &#123;<br>    Checksum16(); <span class="hljs-comment">// constructor</span><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>; <span class="hljs-comment">// prepare unit for computation</span><br>    <span class="hljs-type">void</span> update&lt;T&gt;(in T data); <span class="hljs-comment">// add data to checksum</span><br>    <span class="hljs-type">void</span> remove&lt;T&gt;(in T data); <span class="hljs-comment">// remove data from existing checksum</span><br>    bit&lt;16&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span>; <span class="hljs-comment">// get the checksum for the data added since last clear</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>P4</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TofinoP4学习笔记</title>
    <link href="/2022/11/19/TofinoP4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/19/TofinoP4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Intel-Tofino"><a href="#Intel-Tofino" class="headerlink" title="Intel Tofino"></a>Intel Tofino</h2><img src="/2022/11/19/TofinoP4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/arc.png" class="" title="图片引用方法一"><p>图上是</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>P4</tag>
      
      <tag>Tofino</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openflow学习笔记</title>
    <link href="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-OpenFlow"><a href="#Introduction-to-OpenFlow" class="headerlink" title="Introduction to OpenFlow"></a>Introduction to OpenFlow</h2><p>什么是OpenFlow协议？</p><p>一个标准化的协议，可以与不同厂商的交换机的转发行为进行交互。OpenFlow是很多SDN中的一个key protocol，能够动态、编程的管理网络中交换机的行为。</p><h2 id="简单实验"><a href="#简单实验" class="headerlink" title="简单实验"></a>简单实验</h2><img src="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/topo.png" class="" title="图片引用方法一"><p>S1是openflow kernel switch，C0是reference controller。下面四个是host主机。在h4上运行一个web server，并且从h1发送一个http 请求。</p><p>实验使用的是mininet进行模拟，先配置环境。</p><h3 id="Mininet环境配置"><a href="#Mininet环境配置" class="headerlink" title="Mininet环境配置"></a>Mininet环境配置</h3><img src="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/setup.png" class="" title="图片引用方法一"><p>之前学习mininet教程的时候是直接sudo apt-get install mininet命令安装的，感觉下的不全。但是直接使用-a参数全部下载的时候会报错，提示的错误信息如下图所示。</p><img src="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/error.png" class="" title="图片引用方法一"><p>这个问题直接搜的时候搜不出来太多有用的解决方法，后来直接上网搜索undefined pthread_yield，发现有可能是因为这不是一个标准的方法，<a href="https://stackoverflow.com/questions/73367523/pthread-yield-problem-compiling-32-bit-program">https://stackoverflow.com/questions/73367523/pthread-yield-problem-compiling-32-bit-program</a> 中建议替换成sched_yield。</p><p>因此直接修改了wc_event.c文件中的源代码：</p><img src="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/modify.png" class="" title="图片引用方法一"><p>但是因为install.sh中的文件是完整的，已经git clone了其他库的代码就不能从头完整执行一遍，因此是从代码中对应没有执行完的cbench函数直接逐条命令复制到bash中执行的。不过还需要注意$DIST、$INSTALL这种需要对应代码一开始的变量设置。</p><p>最终这样执行完毕后（也不确定算不算完全安装好，但是后续安装过程中也没有再报错，希望能用。。。），使用官方安装文档中的一个测试命令试了一下，可以正常运行。</p><img src="/2022/11/17/openflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/test.png" class="" title="图片引用方法一"><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data无损压缩</title>
    <link href="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/"/>
    <url>/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="研究问题-amp-动机"><a href="#研究问题-amp-动机" class="headerlink" title="研究问题&amp;动机"></a>研究问题&amp;动机</h2><p>传统的data deduplication是对整个数据块进行去重，而去重需要两个数据块完全相同，才能认为有相同的base。但对于time series data（论文中举的例子是传感器检测温度的数据）来说，相邻的数据块可能会非常相似，但是因为不是完全相同，所以没有办法去重（现有的研究也有提出一种multi-step的方法，即当出现第一个重复的chunk，除了去重之外，还要遍历一遍查找相似的chunk，再进行delta compression）。因此提出的压缩算法适合压缩相似但不完全相同的时序数据。</p><p>通用的基于LZ的压缩算法不适合大规模数据，因为他们的窗口比较小，并且没有办法考虑全局的数据。因此在这种基础上，为大规模数据提出了data deduplication的概念。</p><h2 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h2><p>整个压缩的主要逻辑就是要将chunk分成两部分，一部分是basis（用于deduplication），另一部分是deviation（直接存储不进行压缩）。</p><p>如果选择deviation的长度为2个字节，那么可以对2^16 &#x3D; 65536个相似的数据块进行去重。</p><p>假设一共有c个chunk，不妨分别记为z<sub>1</sub>, z<sub>2</sub>,…,z<sub>c</sub>。并且每一个chunk的长度都是n比特。压缩算法会把每一个chunk z<sub>i</sub>分割成两个部分，一个是长度为k的base x<sub>i</sub>，另一个是长度为m的deviation y<sub>i</sub>。</p><p>但是在压缩之前会先进行一个移位的操作，因为在time series data中，通常会有一些bits跟其余部分的关联性很低（比如LSB的数据很难根据MSB的数据进行推测，这两个关联性不大）。想要实现的是尽可能的分成两个关联性低的部分。</p><p>为了定量的精确衡量这种关联性的大小，使用两个随机变量的互信息来定义：</p><p>$$I(x,y) &#x3D; H(x) + H(Y) - H(X, Y)$$</p><p>如果假设deviation的长度m是已知的，J是对应deviation的下标集合，那么移位的操作希望最小化H(Z<sub>J</sub>, Z<sub>J<sup>C</sup></sub>)的互信息取值。</p><p>当chunk很大的时候，一一枚举开销非常大，使用贪心算法进行m次迭代：</p><img src="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/greedy.png" class="" title="图片引用方法一"><p>（或者也可以设置停止条件，但是可能迭代次数会更多？）</p><p>这样的压缩算法可以保证稳定性（某些chunk损坏不会影响剩下其他chunk的压缩和解压）和对数据的即时存储、搜索和查找。</p><p><strong>重点：估计过程只需要用training set做一次！可以开始的时候系统先不压缩，收集一定量的数据完成估计过程，确定J的下标集合</strong></p><p>因为还需要解压，所以还需要对J进行存储。因为J中的内容是m个取值范围不会超过n的整数，所以可以用Elias gamma code进行编码。这样编码之后需要的空间不会超过$m(2logn+1)$。</p><p>压缩过程需要一个deduplication dictionary（初始是一个空词典），用来存储已经出现过的base。</p><img src="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/dict.png" class="" title="图片引用方法一"><p>如果已经出现，换成对应id+deviation。</p><h2 id="压缩性能"><a href="#压缩性能" class="headerlink" title="压缩性能"></a>压缩性能</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个压缩算法的最明显的好处是每一个chunk只需要一次pass就可以压缩完成，并且需要移位的下标信息可以预训练获得，可以使用多次。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode合集</title>
    <link href="/2022/11/11/LeetCode%E5%90%88%E9%9B%86/"/>
    <url>/2022/11/11/LeetCode%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode1704-判断字符串两段是否相等"><a href="#LeetCode1704-判断字符串两段是否相等" class="headerlink" title="LeetCode1704 判断字符串两段是否相等"></a>LeetCode1704 判断字符串两段是否相等</h2><p>题目整体没有什么难度，使用了最简单的得到两个子串后分别计数并比较是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">halvesAreAlike</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> length = s.length();<br>        <span class="hljs-built_in">string</span> firstHalfStr = s.substr(<span class="hljs-number">0</span>, length / <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">string</span> SecondHalfStr = s.substr(length / <span class="hljs-number">2</span>, length / <span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">if</span>(isTwoStrSame(firstHalfStr, SecondHalfStr)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isTwoStrSame</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span> &#123;<br>        <span class="hljs-type">int</span> num1 = getNum(str1);<br>        <span class="hljs-type">int</span> num2 = getNum(str2);<br><br>        <span class="hljs-keyword">if</span>(num1 == num2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1)</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> len = str1.length();<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;<br>            <span class="hljs-keyword">if</span>(str1[i] == <span class="hljs-string">&#x27;a&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;A&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;e&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;E&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;i&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;I&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;o&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;O&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;u&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>                num += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这样开销比较大，看题解发现还可以使用双指针或者使用位运算。</p><h2 id="LeetCode202-快乐数"><a href="#LeetCode202-快乐数" class="headerlink" title="LeetCode202 快乐数"></a>LeetCode202 快乐数</h2><p>题目整体比较简单，核心思路大致为需要使用一个set保存已经出现过的平方和取值，每次计算时候需要在集合中进行查找，如果搜索到中止，如果没有搜索到将这个值加入集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; all_sum_results;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> current_value = n;<br>        <span class="hljs-type">int</span> current_value_sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!flag) &#123;<br>            current_value_sum = getSum(current_value);<br>            current_value = current_value_sum;<br><br>            <span class="hljs-keyword">if</span>(current_value_sum == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(all_sum_results.find(current_value_sum) != all_sum_results.end()) &#123;<br>                <span class="hljs-comment">//already exists! loop occurred</span><br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                all_sum_results.insert(current_value_sum);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>private:<br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> current_value)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; num_bits;<br>    <span class="hljs-type">int</span> sum_value = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(current_value) &#123;<br>        sum_value += (current_value % <span class="hljs-number">10</span>) * (current_value % <span class="hljs-number">10</span>);<br>        current_value /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum_value;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他解题思路使用<strong>快慢指针</strong>来找出循环，非常巧妙，避免当set太大的时候存储开销过大。（循环的时候判断此时取值是否为1，如果是1说明是快乐数，如果不是1说明出现loop）</p><p>其他一些位运算的使用技巧可以参考<a href="https://www.zhihu.com/question/38206659%E3%80%82">https://www.zhihu.com/question/38206659。</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> slow = n, fast = n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = bitSquareSum(slow);<br>            fast = bitSquareSum(fast);<br>            fast = bitSquareSum(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1710-卡车上的最大单元数"><a href="#LeetCode1710-卡车上的最大单元数" class="headerlink" title="LeetCode1710 卡车上的最大单元数"></a>LeetCode1710 卡车上的最大单元数</h2><p>思路比较简单，在truckSize允许的前提下每次都选择对应unit最大的boxType。所以需要对一个二维数组按照按照unit数目进行排序。</p><p>需要自定义vector sort中的比较器。需要注意，comp函数需要定义为static类型，否则编译报错。</p><p>同时因为每次拿完一个就调用了erase函数，所以需要考虑到仍然有剩余空间但已经没有箱子的情况，否则会运行报内存错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">maximumUnits</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; boxTypes, <span class="hljs-type">int</span> truckSize)</span> &#123;<br>        <span class="hljs-type">int</span> boxTypeNum = boxTypes.size();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> remainingSize = truckSize;<br><br>        sort(boxTypes.begin(),boxTypes.end(),comp);<br>        <span class="hljs-keyword">while</span>(remainingSize != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(boxTypes.empty()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> currentNum = boxTypes[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> currentUnit = boxTypes[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">if</span>(currentNum &lt;= remainingSize) &#123;<br>                remainingSize -= currentNum;<br>                res += currentNum * currentUnit;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res += remainingSize * currentUnit;<br>                remainingSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            boxTypes.erase(boxTypes.begin());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>private:<br>    <span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">comp</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; box1, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; box2)</span> &#123;<br>        <span class="hljs-keyword">return</span> box1[<span class="hljs-number">1</span>] &gt; box2[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="LeetCode-1603设计停车系统"><a href="#LeetCode-1603设计停车系统" class="headerlink" title="LeetCode 1603设计停车系统"></a>LeetCode 1603设计停车系统</h2><p>这个题目没有难点，简单维护一个现有车位的变量即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParkingSystem</span> &#123;</span><br>public:<br>    ParkingSystem(<span class="hljs-type">int</span> big, <span class="hljs-type">int</span> medium, <span class="hljs-type">int</span> small) &#123;<br>        RemainingBig = big;<br>        RemainingMed = medium;<br>        RemainingSmall = small;<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">addCar</span><span class="hljs-params">(<span class="hljs-type">int</span> carType)</span> &#123;<br>        <span class="hljs-keyword">if</span>(carType == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>(RemainingBig &gt;= <span class="hljs-number">1</span>) &#123;<br>                RemainingBig -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(carType == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(RemainingMed &gt;= <span class="hljs-number">1</span>) &#123;<br>                RemainingMed -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(carType == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">if</span>(RemainingSmall &gt;= <span class="hljs-number">1</span>) &#123;<br>                RemainingSmall -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>private:<br>    <span class="hljs-type">int</span> RemainingBig;<br>    <span class="hljs-type">int</span> RemainingMed;<br>    <span class="hljs-type">int</span> RemainingSmall;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1752-检查数组是否经排序和轮转得到"><a href="#LeetCode1752-检查数组是否经排序和轮转得到" class="headerlink" title="LeetCode1752 检查数组是否经排序和轮转得到"></a>LeetCode1752 检查数组是否经排序和轮转得到</h2><p>考虑到源数组是非递减顺序，所以如果可以轮转得到，数组实际上是分为两部分，左边部分是一个递增序列，右边部分是一个递减的序列。所以考虑使用双指针来解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">check</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        <span class="hljs-type">int</span> size = nums.size();<br>        <span class="hljs-type">int</span> left_pointer =  <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right_pointer = size - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">bool</span> move_flag_1 = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">bool</span> move_flag_2 = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-comment">//special case</span><br>        &#125; <br>        <span class="hljs-keyword">while</span>(left_pointer != right_pointer) &#123;<br>            move_flag_1 = <span class="hljs-literal">false</span>;<br>            move_flag_2 = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">if</span>(nums[left_pointer+<span class="hljs-number">1</span>] &gt;= nums[left_pointer]) &#123;<br>                left_pointer += <span class="hljs-number">1</span>;<br>                move_flag_1 = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[right_pointer<span class="hljs-number">-1</span>] &lt;= nums[right_pointer]) &#123;<br>                right_pointer -= <span class="hljs-number">1</span>;<br>                move_flag_2 = <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(left_pointer &gt;= right_pointer) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">//forget third condition </span><br>            <span class="hljs-keyword">if</span>((left_pointer == right_pointer - <span class="hljs-number">1</span>) &amp;&amp; (nums[left_pointer] &gt;= nums[size<span class="hljs-number">-1</span>]) &amp;&amp; (nums[size<span class="hljs-number">-1</span>] &lt;= nums[<span class="hljs-number">0</span>])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!(move_flag_1||move_flag_2)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>但是这样的思路只能通过101&#x2F;105个测试用例，一个无法通过的示例为[2,4,1,3]。最终left_pointer停在4，right_pointer停在1，且满足4比3大。但是忘记考虑数组起始两个下标之间的关系，加上第三个条件式(nums[size-1] &lt;&#x3D; nums[0])通过。</p><h2 id="LeetCode1614-括号的最大嵌套深度"><a href="#LeetCode1614-括号的最大嵌套深度" class="headerlink" title="LeetCode1614 括号的最大嵌套深度"></a>LeetCode1614 括号的最大嵌套深度</h2><p>因为是涉及到括号匹配以及最大深度的问题，所以使用stack。一开始想的很麻烦，想要在pop的时候判断栈中是否为空，从而确定是需要做max操作还是直接相加。</p><p>后来直接看解题思路发现最大深度其实只需要判断栈中元素个数最多时候的数值即可。因此在push和pop的时候同时维护一个size，实现比较简单。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> length = s.length();<br>        <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">char</span>&gt; parenthese;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; length;i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                parenthese.push(s[i]);<br>                depth += <span class="hljs-number">1</span>;<br>                res = max(res, depth);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                parenthese.pop();<br>                depth -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1732-找到最高海拔"><a href="#LeetCode1732-找到最高海拔" class="headerlink" title="LeetCode1732 找到最高海拔"></a>LeetCode1732 找到最高海拔</h2><p>题目非常简单，只需要维护一个maxHeight变量并且在循环的时候不断更新当前最大值即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">largestAltitude</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; gain)</span> &#123;<br>        <span class="hljs-type">int</span> maxHeight = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> currentHeight = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; gain.size();i++) &#123;<br>            currentHeight += gain[i];<br>            maxHeight = max(maxHeight, currentHeight);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> maxHeight;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1051-高度检查器"><a href="#LeetCode1051-高度检查器" class="headerlink" title="LeetCode1051 高度检查器"></a>LeetCode1051 高度检查器</h2><p>这个题目没有什么难度，最直观的方法直接调用algorithm库中的sort函数进行排序，并且再循环一次找到不匹配的数目即可。</p><p>这样需要额外复制一个数组，空间复杂度为O(N)，或者可以自己实现排序算法，统计每一次交换即可进一步优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">heightChecker</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> size = heights.size();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; sorted_heights = heights;<br><br>        sort(sorted_heights.begin(), sorted_heights.end());<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(sorted_heights[i] != heights[i]) &#123;<br>                res += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode2469-温度转换"><a href="#LeetCode2469-温度转换" class="headerlink" title="LeetCode2469 温度转换"></a>LeetCode2469 温度转换</h2><p>看到题目有误差要求以为需要进行类型转换才能得到正确数据，但是直接写也能ac，没有难度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">convertTemperature</span><span class="hljs-params">(<span class="hljs-type">double</span> celsius)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt; res;<br><br>        res.push_back(celsius + <span class="hljs-number">273.15</span>);<br>        res.push_back(celsius * <span class="hljs-number">1.80</span> + <span class="hljs-number">32.00</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode2236-断根结点是否等于子结点之和"><a href="#LeetCode2236-断根结点是否等于子结点之和" class="headerlink" title="LeetCode2236 断根结点是否等于子结点之和"></a>LeetCode2236 断根结点是否等于子结点之和</h2><p>题目已经给出二叉树恰好有三个节点，所以不用判断指针是否null，直接加和即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">checkTree</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root -&gt; val == (root-&gt;left -&gt; val) + (root -&gt; right -&gt; val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1929-数组串联"><a href="#LeetCode1929-数组串联" class="headerlink" title="LeetCode1929 数组串联"></a>LeetCode1929 数组串联</h2><p>题目没有难度，不过为了减小空间消耗可以直接在数组后面继续添加，用取模运算对应下标即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">getConcatenation</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        <span class="hljs-type">int</span> size = nums.size();<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = size;i &lt; size * <span class="hljs-number">2</span>;i++) &#123;<br>            nums.push_back(nums[i % size]);<br>        &#125; <br><br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1672-最富有的客户资产总量"><a href="#LeetCode1672-最富有的客户资产总量" class="headerlink" title="LeetCode1672 最富有的客户资产总量"></a>LeetCode1672 最富有的客户资产总量</h2><p>题目很简单，维护一个max_assets每次循环一行更新即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">maximumWealth</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; accounts)</span> &#123;<br>        <span class="hljs-type">int</span> max_assets = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> row = accounts.size();<br>        <span class="hljs-type">int</span> col = accounts[<span class="hljs-number">0</span>].size();   <span class="hljs-comment">//input is not empty</span><br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> j;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; row; i++) &#123;<br>            <span class="hljs-type">int</span> current_assets = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; col; j++) &#123;<br>                current_assets += accounts[i][j];<br>            &#125;<br>            max_assets = max(max_assets, current_assets);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_assets;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1742-盒子中小球的最大数量"><a href="#LeetCode1742-盒子中小球的最大数量" class="headerlink" title="LeetCode1742 盒子中小球的最大数量"></a>LeetCode1742 盒子中小球的最大数量</h2><p>因为给出的盒子无限，并且也不知道小球加和的范围，所以不能直接自己声明一个vector<int>，并且把对应下标作为盒子的编号，这样会导致空间的浪费。所以使用C++中的stl map类型，用来记录对应box id以及存放小球的数目。最后实现一个自定义的比较函数cmp，找到map中value最大的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C">public:<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">countBalls</span><span class="hljs-params">(<span class="hljs-type">int</span> lowLimit, <span class="hljs-type">int</span> highLimit)</span> &#123;<br>        <span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; index_num_box;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = lowLimit; i &lt;= highLimit; i++) &#123;<br>            <span class="hljs-type">int</span> currentIndex = getSum(i);<br>            <span class="hljs-keyword">if</span>(index_num_box.find(currentIndex) != index_num_box.end()) &#123;<br>                index_num_box[currentIndex] += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                index_num_box[currentIndex] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> max_element(index_num_box.begin(), index_num_box.end(), cmp) -&gt; second;<br>    &#125;<br>private:<br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(num) &#123;<br>        res += num % <span class="hljs-number">10</span>;<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pair1, <span class="hljs-type">const</span> <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pair2)</span> &#123;<br>    <span class="hljs-keyword">return</span> pair1.second &lt; pair2.second;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode14-最长公共前缀"><a href="#LeetCode14-最长公共前缀" class="headerlink" title="LeetCode14 最长公共前缀"></a>LeetCode14 最长公共前缀</h2><p>考虑每个匹配的char都要进行一遍循环，直到遇到了第一个不匹配的字符或者某个字符串已经匹配完成（长度最小）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">string</span> <span class="hljs-title function_">longestCommonPrefix</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> &#123;<br>        <span class="hljs-built_in">string</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> string_num = strs.size();<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> res_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">if</span>(string_num == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(flag) &#123;<br>            <span class="hljs-type">char</span> current_char = <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; string_num; i++) &#123;<br>                <span class="hljs-built_in">string</span> current_string = strs[i];<br><br>                <span class="hljs-keyword">if</span>(current_string.size() == res_num) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//come to the minimum length string</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                    current_char = current_string[res_num];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_string[res_num] != current_char) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//mismatch</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                res += current_char;<br>                res_num += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看题解发现可以先对strs进行排序，排序之后比较第一个和最后一个字符串即可，他们两个的相同部分是所有str的最长公共前缀。</p><h2 id="LeetCode541-反转字符串"><a href="#LeetCode541-反转字符串" class="headerlink" title="LeetCode541 反转字符串"></a>LeetCode541 反转字符串</h2><p>题目本身难度不大，不过需要考虑各种情况，并且下标处理的时候想了很久，需要多考虑几个例子。为了避免每种情况都写一个循环，所以先做判断并且记录需要增加的step，三种情况用相同的循环体去处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">string</span> <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> left_pointer = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> str_length = s.size();<br>        <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> current_k = k;<br><br>        <span class="hljs-keyword">while</span>(left_pointer &lt; str_length) &#123;<br>            <span class="hljs-type">int</span> right_pointer = left_pointer + k * <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span>(right_pointer &lt;= str_length) &#123;<br>                <span class="hljs-comment">//left_pointer += 2 * k;</span><br>                step = <span class="hljs-number">2</span> * k;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left_pointer + k &lt;= str_length) &#123;<br>                <span class="hljs-comment">//left_pointer = str_length;</span><br>                step = str_length - left_pointer;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left_pointer &lt; str_length) &#123;<br>                <span class="hljs-comment">//反转剩下的全部</span><br>                current_k = str_length - left_pointer;<br>                step = str_length - left_pointer;<br>            &#125;<br><br>            <span class="hljs-comment">//正常反转k个</span><br>            <span class="hljs-type">int</span> i = left_pointer;<br>            <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; current_k / <span class="hljs-number">2</span>;j++) &#123;<br>                <span class="hljs-type">char</span> current_invert_char = s[left_pointer + current_k - j - <span class="hljs-number">1</span>];<br>                s[left_pointer + current_k - j - <span class="hljs-number">1</span>] = s[i];<br>                s[i] = current_invert_char;<br>                i++;<br>            &#125;<br><br>            left_pointer += step;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode111-二叉树的最小深度"><a href="#LeetCode111-二叉树的最小深度" class="headerlink" title="LeetCode111 二叉树的最小深度"></a>LeetCode111 二叉树的最小深度</h2><p>题目比较简单，不过不能直接当root为null的时候返回0，这样会导致边树的最小深度永远为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-keyword">if</span>(root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        TreeNode* left_child = root -&gt; left;<br>        TreeNode* right_child = root -&gt; right;<br><br>        <span class="hljs-keyword">if</span>(left_child == nullptr &amp;&amp; right_child == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left_child == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(right_child);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right_child == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + minDepth(left_child);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min(minDepth(left_child), minDepth(right_child)) + <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode108-将有序数组转换为二叉搜索树"><a href="#LeetCode108-将有序数组转换为二叉搜索树" class="headerlink" title="LeetCode108 将有序数组转换为二叉搜索树"></a>LeetCode108 将有序数组转换为二叉搜索树</h2><p>给定一个升序的数组，需要将他转变为一个BST。实际上，这个BST的中序遍历就是对应的升序数组，但是如果只给定了BST的中序遍历，并不能唯一确定对应的树。就算加上了高度平衡（左右子树高度差小于等于1），也不能唯一确定（因为数组长度一定存在是偶数的情况，中间下标可以有两种情况）。</p><img src="/2022/11/11/LeetCode%E5%90%88%E9%9B%86/bst.png" class="" title="图片引用方法一"><p>很直观的想法是中间的数会作为root节点，然后左边数组对应构造左子树，右边数组对应构造右子树。递归完成即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C">TreeNode* <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        TreeNode* root = nullptr;<br>        <span class="hljs-type">int</span> middle_index = nums.size() / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> nullptr;<br>        &#125;<br><br>        root = new TreeNode(nums[middle_index]);<br><br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">left_arr</span><span class="hljs-params">(nums.begin(), nums.begin() + middle_index)</span>;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">right_arr</span><span class="hljs-params">(nums.begin() + middle_index + <span class="hljs-number">1</span>, nums.end())</span>;<br><br>        root-&gt;left = sortedArrayToBST(left_arr);<br>        root-&gt;right = sortedArrayToBST(right_arr);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode2169-得到0的操作数"><a href="#LeetCode2169-得到0的操作数" class="headerlink" title="LeetCode2169 得到0的操作数"></a>LeetCode2169 得到0的操作数</h2><p>很简单，直接判断即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">countOperations</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(num1 != <span class="hljs-number">0</span> &amp;&amp; num2 != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span>(num1 &gt;= num2) &#123;<br>                num1 = num1 - num2;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                num2 = num2 - num1;<br>            &#125;<br><br>            res += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode2185-统计包含给定前缀的字符串"><a href="#LeetCode2185-统计包含给定前缀的字符串" class="headerlink" title="LeetCode2185 统计包含给定前缀的字符串"></a>LeetCode2185 统计包含给定前缀的字符串</h2><p>遍历一遍str数组，对每一个字符串提取前缀长度的子串，并判断是否相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">prefixCount</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words, <span class="hljs-built_in">string</span> pref)</span> &#123;<br>        <span class="hljs-type">int</span> size = words.size();<br>        <span class="hljs-type">int</span> pref_size = pref.length();<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size; i++) &#123;<br>            <span class="hljs-built_in">string</span> current_pref = words[i].substr(<span class="hljs-number">0</span>, pref_size);<br><br>            <span class="hljs-keyword">if</span>(current_pref == pref) &#123;<br>                count += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1758-生成交替二进制字符串的最少操作数"><a href="#LeetCode1758-生成交替二进制字符串的最少操作数" class="headerlink" title="LeetCode1758 生成交替二进制字符串的最少操作数"></a>LeetCode1758 生成交替二进制字符串的最少操作数</h2><p>一开始的做题思路是分别从左右两边循环一遍，找出对应操作数，并且返回两者之间的较小值。但是这样只能通过81&#x2F;89个case，比如考虑10010100这个串，不管是左边还是右边对应的操作数都是5，实际上最小的操作数是3。</p><p>直观看这样的原因是如果只考虑左右两边的情况，实际上只对应保留左边第一个字符不修改和保留右边第一个字符不修改，没有考虑实际上首尾两个元素都进行修改的情况。</p><p>所以又加了第三遍循环，考虑首尾字符都修改的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> left_op = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right_op = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> both_op = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> size = s.length();<br>        <span class="hljs-built_in">string</span> another_s = s;<br>        <span class="hljs-built_in">string</span> another_s_1 = s;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0 &#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                s[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>                left_op += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                s[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                left_op += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(i = size - <span class="hljs-number">1</span>;i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">if</span>(another_s[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; another_s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(another_s[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; another_s[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(another_s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                another_s[i<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>                right_op += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(another_s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                another_s[i<span class="hljs-number">-1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                right_op += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        another_s_1[<span class="hljs-number">0</span>] = another_s_1[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-string">&#x27;1&#x27;</span>;<br>        another_s_1[size<span class="hljs-number">-1</span>] = another_s_1[size<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(another_s_1[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; another_s_1[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(another_s_1[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; another_s_1[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0 &#x27;</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(another_s_1[i] == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; another_s_1[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                another_s_1[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>                both_op += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(another_s_1[i] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; another_s_1[i+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                another_s_1[i+<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                both_op += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> min(min(left_op, right_op), both_op);<br>    &#125;<br></code></pre></td></tr></table></figure><p>题解中的思路更简单，一个字符串s最终可以有两个交替字符串，分别是以0开头和以1开头的情况。并且这两种的操作数之和等于整个字符串的长度。所以实际只需要遍历一遍，就可以直接相减得到另外一个的操作数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.size(); i++) &#123;<br>            <span class="hljs-type">char</span> c = s[i];<br>            <span class="hljs-keyword">if</span> (c != (<span class="hljs-string">&#x27;0&#x27;</span> + i % <span class="hljs-number">2</span>)) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> min(cnt, (<span class="hljs-type">int</span>)s.size() - cnt);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode2451-差值数组不同的字符串"><a href="#LeetCode2451-差值数组不同的字符串" class="headerlink" title="LeetCode2451 差值数组不同的字符串"></a>LeetCode2451 差值数组不同的字符串</h2><p>这个题的难度在于如何高效的找到一个数组中的不重复元素。一开始想的是在计算过程中就一起维护一个diff_index，从而不需要额外再判断一遍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(current_diff != diff[diff_index]) &#123;<br>    diff_index = i;<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上只要当出现不一致的时候，能够再向前或者向后找一个元素，用三个元素就可以判断出到底哪个是重复的哪个是唯一的。所以最终用一个flag，如果找到第一个不一样的元素，就再向后算一个diff，加入vector并中止循环。这样会减少时间复杂度，因为只要找到有不一样的元素就可以退出，如果唯一元素出现的位置比较靠前而数组又很长，可以省去计算后面元素的开销。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">string</span> <span class="hljs-title function_">oddString</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&amp; words)</span> &#123;<br>        <span class="hljs-type">int</span> length = words.size();<br>        <span class="hljs-type">int</span> str_length = words[<span class="hljs-number">0</span>].size();<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt; diff;<br>        <span class="hljs-type">int</span> diff_index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> j;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt;length;i++) &#123;<br>            <span class="hljs-built_in">string</span> current_str = words[i];<br>            <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; current_diff;<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; str_length - <span class="hljs-number">1</span>;j++) &#123;<br>                current_diff.push_back(current_str[j+<span class="hljs-number">1</span>] - current_str[j]);<br>            &#125;<br>            diff.push_back(current_diff);<br>            <span class="hljs-keyword">if</span>(flag) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(current_diff != diff[diff_index]) &#123;<br>                diff_index = i;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//可以计算出下一个元素，不会直接退出循环</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(diff_index &gt; <span class="hljs-number">0</span> &amp;&amp; diff_index &lt;= length - <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span>(diff[diff_index] == diff[diff_index+<span class="hljs-number">1</span>]) &#123;<br>                diff_index -= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> words[diff_index];<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1779-找到最近的有相同-X-或-Y-坐标的点"><a href="#LeetCode1779-找到最近的有相同-X-或-Y-坐标的点" class="headerlink" title="LeetCode1779 找到最近的有相同 X 或 Y 坐标的点"></a>LeetCode1779 找到最近的有相同 X 或 Y 坐标的点</h2><p>比较简单，在循环判断坐标是否有效的同时维护min_dist以及对应下标index即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">nearestValidPoint</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> &#123;<br>        <span class="hljs-type">int</span> size = points.size();<br>        <span class="hljs-type">int</span> min_dist = <span class="hljs-number">10001</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;   <br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] == x || points[i][<span class="hljs-number">1</span>] == y) &#123;<br>                <span class="hljs-comment">//a valid point</span><br>                <span class="hljs-type">int</span> current_dist = <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">0</span>] - x) + <span class="hljs-built_in">abs</span>(points[i][<span class="hljs-number">1</span>] - y);<br>                <span class="hljs-keyword">if</span>(current_dist &lt; min_dist) &#123;<br>                    index = i;<br>                    min_dist = current_dist;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode100-相同的树"><a href="#LeetCode100-相同的树" class="headerlink" title="LeetCode100 相同的树"></a>LeetCode100 相同的树</h2><p>题目非常简单，因为树相关的问题大部分都是递归完成，即分解成左子树和右子树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> &#123;<br>        <span class="hljs-keyword">if</span>(p == nullptr &amp;&amp; q == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p == nullptr || q == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(p -&gt; val == q -&gt; val) &#123;<br>            <span class="hljs-keyword">return</span> isSameTree(p -&gt; left, q -&gt; left) &amp;&amp; isSameTree(p -&gt; right, q -&gt; right);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode88-合并两个有序数组"><a href="#LeetCode88-合并两个有序数组" class="headerlink" title="LeetCode88 合并两个有序数组"></a>LeetCode88 合并两个有序数组</h2><p>本来以为是给每个数组弄一个指针比较放进数组，但是发现跟之前做的不太一样，需要把结果保存到其中一个已经预先分配好空间的vector中。而如果再用之前的方法，从左边开始依次比较，则每次比较出需要从另一个数组插入的时候，会发现需要把原来的每个都往后移一个。</p><p>看了题解的思路，是从后往前确定放进去哪个，并且当另外一个数组的全部元素都正确插入后循环结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> nums1_pointer = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> nums2_pointer =  n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> total_size = m + n;<br>        <span class="hljs-type">int</span> current_insert_index = total_size - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>) &#123;<br>            nums1 = nums2;<span class="hljs-comment">//直接赋值</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(nums2_pointer &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//nums2中仍然有元素没有插完</span><br>            <span class="hljs-keyword">if</span>(nums1_pointer &lt; <span class="hljs-number">0</span>) &#123;<br>                nums1[current_insert_index] = nums2[nums2_pointer];<br>                nums2_pointer --;<br>                current_insert_index --;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;   <span class="hljs-comment">//如果最前面是空的，数组下标会减到-1</span><br><br>            <span class="hljs-type">int</span> current_num1_val = nums1[nums1_pointer];<br>            <span class="hljs-type">int</span> current_num2_val = nums2[nums2_pointer];<br><br>            <span class="hljs-keyword">if</span>(current_num1_val &lt; current_num2_val) &#123;<br>                nums1[current_insert_index] = current_num2_val;<br>                nums2_pointer --;<br>                current_insert_index --;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_num1_val &gt;= current_num2_val) &#123;<br>                nums1[nums1_pointer] = <span class="hljs-number">0</span>;<br>                nums1[current_insert_index] = current_num1_val;<br>                nums1_pointer --;<br>                current_insert_index --;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1796-字符串中第二大的数字"><a href="#LeetCode1796-字符串中第二大的数字" class="headerlink" title="LeetCode1796 字符串中第二大的数字"></a>LeetCode1796 字符串中第二大的数字</h2><p>题目难度不大，因为使用set存出现过的数字，可以直接调用insert不需要在自己判断元素是否出现的逻辑，并且会自己排序，也不需要再额外调用sort函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">secondHighest</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; nums;<br>        <span class="hljs-type">int</span> size = s.size();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                nums.insert(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums.size() &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//sort(nums.begin(),nums.end());</span><br><br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt;::iterator it = nums.end();<br>        it --;<br>        it --;<br>        res = *(it);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode771-宝石与石头"><a href="#LeetCode771-宝石与石头" class="headerlink" title="LeetCode771 宝石与石头"></a>LeetCode771 宝石与石头</h2><p>非常简单，循环遍历一遍并且对每个字符都判断是否是宝石，因此将判断逻辑单独抽象出来写成一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">numJewelsInStones</span><span class="hljs-params">(<span class="hljs-built_in">string</span> jewels, <span class="hljs-built_in">string</span> stones)</span> &#123;<br>        <span class="hljs-type">int</span> size = stones.size();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span>(isJewel(jewels, stones[i])) &#123;<br>                res ++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isJewel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> jewels, <span class="hljs-type">char</span> current_stone)</span> &#123;<br>        <span class="hljs-type">int</span> size = jewels.size();<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span>(jewels[i] == current_stone) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1486-数组异或操作"><a href="#LeetCode1486-数组异或操作" class="headerlink" title="LeetCode1486 数组异或操作"></a>LeetCode1486 数组异或操作</h2><p>直接用遍历进行按位异或的操作，但是感觉应该会有更简单的数学上的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">xorOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> start)</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> res = start;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; n;i++) &#123;<br>            <span class="hljs-type">int</span> current_val = start + <span class="hljs-number">2</span> * i;<br>            res  = res ^ current_val;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><img src="/2022/11/11/LeetCode%E5%90%88%E9%9B%86/sumxor.png" class="" title="图片引用方法一"><h2 id="LeetCode824-山羊拉丁文"><a href="#LeetCode824-山羊拉丁文" class="headerlink" title="LeetCode824 山羊拉丁文"></a>LeetCode824 山羊拉丁文</h2><p>处理逻辑比较简单，注意到可以直接用stringstream来完成给定string按照空格分隔。并且直接在分隔的同时对word进行逐词处理，不用先转成vector<string>之后再遍历一遍处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C">public:<br>    <span class="hljs-built_in">string</span> <span class="hljs-title function_">toGoatLatin</span><span class="hljs-params">(<span class="hljs-built_in">string</span> sentence)</span> &#123;<br>        <span class="hljs-built_in">string</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">string</span> current_word = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">stringstream</span> <span class="hljs-title function_">str_input</span><span class="hljs-params">(sentence)</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(str_input &gt;&gt; current_word) &#123;<br>            <span class="hljs-type">int</span> i;<br><br>            <span class="hljs-keyword">if</span>(isVowel(current_word[<span class="hljs-number">0</span>])) &#123;<br>                res += current_word + <span class="hljs-string">&quot;ma&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                res += performNonVowelChange(current_word) + <span class="hljs-string">&quot;ma&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                res += <span class="hljs-string">&quot;a&quot;</span>;<br>            &#125;<br><br>            res += <span class="hljs-string">&quot; &quot;</span>;<br>            index++;<br>        &#125;<br><br>        res.erase(res.size() - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>private:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isVowel</span><span class="hljs-params">(<span class="hljs-type">char</span> current_char)</span> &#123;<br>        <span class="hljs-keyword">if</span>(current_char == <span class="hljs-string">&#x27;a&#x27;</span> || current_char == <span class="hljs-string">&#x27;e&#x27;</span> || current_char == <span class="hljs-string">&#x27;i&#x27;</span> || current_char == <span class="hljs-string">&#x27;o&#x27;</span> || current_char == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(current_char == <span class="hljs-string">&#x27;A&#x27;</span> || current_char == <span class="hljs-string">&#x27;E&#x27;</span> || current_char == <span class="hljs-string">&#x27;I&#x27;</span> || current_char == <span class="hljs-string">&#x27;O&#x27;</span> || current_char == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">string</span> <span class="hljs-title function_">performNonVowelChange</span><span class="hljs-params">(<span class="hljs-built_in">string</span> original_word)</span> &#123;<br>        <span class="hljs-built_in">string</span> res = original_word;<br>        <br>        res += original_word[<span class="hljs-number">0</span>];<br>        res.erase(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode203-移除链表元素"><a href="#LeetCode203-移除链表元素" class="headerlink" title="LeetCode203 移除链表元素"></a>LeetCode203 移除链表元素</h2><p>因为需要在遍历的同时将相同取值的元素删除，所以同时需要维护一个prev的指针。而且会有可能在head处匹配的值就是相等的，那么还需要修改head的取值，并且因为head前面没有其他元素，所以在head的时候curr和prev是相同的。并且当匹配完成的时候指针已经更新过了，直接continue跳过下面正常的后移一位，否则会有元素被跳过，删除不了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C">ListNode* <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> &#123;<br>        ListNode* current_node = head;<br>        ListNode* prev_node = head;<br><br>        <span class="hljs-keyword">while</span>(current_node != nullptr) &#123;<br>            <span class="hljs-type">int</span> current_val = current_node -&gt; val;<br><br>            <span class="hljs-keyword">if</span>(current_val == val &amp;&amp; current_node == head) &#123;<br>                head = head -&gt; next;<br>                current_node = head;<br>                prev_node = head;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_val == val) &#123;<br>                prev_node -&gt; next = current_node -&gt; next;<br>                current_node = current_node -&gt; next;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(current_node == head &amp;&amp; current_node != nullptr) &#123;<br>                current_node = current_node -&gt; next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_node != nullptr)&#123;<br>                current_node = current_node -&gt; next;<br>                prev_node = prev_node -&gt; next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1790-仅执行一次字符串交换能否使两个字符串相等"><a href="#LeetCode1790-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="LeetCode1790 仅执行一次字符串交换能否使两个字符串相等"></a>LeetCode1790 仅执行一次字符串交换能否使两个字符串相等</h2><p>因为只交换一次就要让两个字符串相等，所以很显然遍历一次两个字符串只能有两个位置的下标对应不上（只有一个不对应或者超过2个不对应都不能满足）。而且一开始只是简单这样比较，会导致一些testcase不过，比如”znb”和”anc”，也是有两个位置的下标无法对应，但是还需要进一步确保对应下标上的字符交换后相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">areAlmostEqual</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2)</span> &#123;<br>        <span class="hljs-type">int</span> size = s1.size();<br>        <span class="hljs-type">int</span> diff_num = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">char</span> diff_s1_first = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">char</span> diff_s2_first = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">char</span> diff_s1_second = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">char</span> diff_s2_second = <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-keyword">if</span>(s1[i] != s2[i]) &#123;<br>                diff_num += <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(diff_num == <span class="hljs-number">1</span>) &#123;<br>                    diff_s1_first = s1[i];<br>                    diff_s2_first = s2[i];<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    diff_s1_second = s1[i];<br>                    diff_s2_second = s2[i];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(diff_num &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(diff_s1_first != diff_s2_second || diff_s2_first != diff_s1_second) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1821-判断国际象棋棋盘中一个格子的颜色"><a href="#LeetCode1821-判断国际象棋棋盘中一个格子的颜色" class="headerlink" title="LeetCode1821 判断国际象棋棋盘中一个格子的颜色"></a>LeetCode1821 判断国际象棋棋盘中一个格子的颜色</h2><p>比较简单，发现当字母坐标和数字坐标之和是偶数的时候，格子才会是黑色的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">squareIsWhite</span><span class="hljs-params">(<span class="hljs-built_in">string</span> coordinates)</span> &#123;<br>        <span class="hljs-type">char</span> coordinate_letter = coordinates[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">char</span> coordinate_number = coordinates[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">if</span>((coordinate_number + coordinate_letter - <span class="hljs-string">&#x27;a&#x27;</span>) % <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1678-设计Goal解析器"><a href="#LeetCode1678-设计Goal解析器" class="headerlink" title="LeetCode1678 设计Goal解析器"></a>LeetCode1678 设计Goal解析器</h2><p>没有难度，因为出现的字符串没有嵌套，只会是顺序出现，而且假设所有字符串都是合法的，因此循环一遍就可以得到解析后的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">string</span> <span class="hljs-title function_">interpret</span><span class="hljs-params">(<span class="hljs-built_in">string</span> command)</span> &#123;<br>        <span class="hljs-built_in">string</span> res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> size = command.size();<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-type">char</span> current_char = command[i];<br><br>            <span class="hljs-keyword">if</span>(current_char == <span class="hljs-string">&#x27;G&#x27;</span>) &#123;<br>                res += <span class="hljs-string">&quot;G&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(current_char == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(command[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                    res += <span class="hljs-string">&quot;o&quot;</span>;<br>                    i += <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(command[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                    res += <span class="hljs-string">&quot;al&quot;</span>;<br>                    i += <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1720-解码异或后的数组"><a href="#LeetCode1720-解码异或后的数组" class="headerlink" title="LeetCode1720 解码异或后的数组"></a>LeetCode1720 解码异或后的数组</h2><p>非常简单，a &#x3D; b ^ c，则 c &#x3D; a ^ b。可以一次遍历解码出原始的数组，注意下标不要越界。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; encoded, <span class="hljs-type">int</span> first)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; original;<br>        <span class="hljs-type">int</span> size = encoded.size() + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        original.push_back(first);<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; size;i++) &#123;<br>            original.push_back(original[i - <span class="hljs-number">1</span>] ^ encoded[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> original;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode1827-最少操作使数组递增"><a href="#LeetCode1827-最少操作使数组递增" class="headerlink" title="LeetCode1827 最少操作使数组递增"></a>LeetCode1827 最少操作使数组递增</h2><p>一开始根据给出的两个例子只考虑到根据前两个数字判断整个数组，但是忽略了可能前n个数字都是递增的情况（如2,6,8,2,3,2）。所以每个数字$num_{i}$当前应该是什么值需要取决于他前一个数字$num_{i-1}$是否小于他，如果小于说明不用变化，如果大于说明变成$num_{i}$+1的操作数是最少的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">minOperations</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> &#123;<br>        <span class="hljs-type">int</span> size = nums.size();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i;<br><br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span> || size == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; size;i++) &#123;<br>            <span class="hljs-type">int</span> current_num = nums[i] &lt;= nums[i<span class="hljs-number">-1</span>] ? nums[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span> : nums[i];<br>            res += current_num - nums[i];<br>            nums[i] = current_num;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode145-二叉树的后序遍历"><a href="#LeetCode145-二叉树的后序遍历" class="headerlink" title="LeetCode145 二叉树的后序遍历"></a>LeetCode145 二叉树的后序遍历</h2><p>后序遍历的顺序是左子树-&gt;右子树-&gt;根节点，并且在遍历之前先判断当前根节点是否为空。不过因为返回的是一个vector，所以需要将左子树和右子树返回回来的vector拼在一起。查到的一个方法是stl中的insert方法，可以实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br><br>        <span class="hljs-keyword">if</span>(root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; left_res = postorderTraversal(root -&gt; left);<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; right_res = postorderTraversal(root -&gt; right);<br>        res.insert(res.end(), left_res.begin(), left_res.end());<br>        res.insert(res.end(), right_res.begin(), right_res.end());<br>        res.push_back(root -&gt; val);<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>但是这样内存开销太大了，参考题解有一种更好的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode *root, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == nullptr) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        postorder(root-&gt;left, res);<br>        postorder(root-&gt;right, res);<br>        res.push_back(root-&gt;val);<br>    &#125;<br><br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode *root)</span> &#123;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br>        postorder(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>浅浅刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库常用压缩算法比较</title>
    <link href="/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <url>/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="比较不同压缩算法trade-off"><a href="#比较不同压缩算法trade-off" class="headerlink" title="比较不同压缩算法trade off"></a>比较不同压缩算法trade off</h2><p>压缩的本质是减少IO操作，从而带来更快的读写操作。需要用CPU周期来对IO性能进行tradeoff。</p><p>但是同时还要考虑到实际应用的性能需求，如实时性、吞吐等。不同压缩算法的cost不同，因此需要综合考虑。</p><h2 id="评估压缩算法的指标"><a href="#评估压缩算法的指标" class="headerlink" title="评估压缩算法的指标"></a>评估压缩算法的指标</h2><ul><li>压缩比 compression ratio</li><li>吞吐 throughput</li><li>压缩速度 compression speed</li><li>解压速度 decompression speed</li><li>内存 memory</li></ul><p>图中给出的是java-based benchmarking，重点比较gzip和snappy两种最通用的算法。</p><p>绿色的指标是compression ratio，越小越好；黄色的指标是throughput，越大越好。</p><p>gzip的压缩比例优于snappy，但snappy的吞吐高于gzip。</p><h2 id="如何选择适合的压缩算法"><a href="#如何选择适合的压缩算法" class="headerlink" title="如何选择适合的压缩算法"></a>如何选择适合的压缩算法</h2><ul><li>选择的压缩算法需要能够支持配置的big data environment（Spark、HIVE、presto、parquet、hadoop、S3、kafka等）</li><li>能够支持serialization format</li><li>考虑数据的生命周期以及访问模式！<br>（对于声明周期长但访问不频繁的cold data可以选择gzip压缩算法，频繁访问的hot data可以选择snappy压缩算法）</li><li>key wordload&amp;split-ability<br>（比如gzip就是不能支持split的数据，所以如果使用hadoop这种map reduce的应用，不选用gzip压缩算法）</li></ul><h2 id="Snappy压缩算法原理"><a href="#Snappy压缩算法原理" class="headerlink" title="Snappy压缩算法原理"></a>Snappy压缩算法原理</h2><p>snappy（又称zippy）是google开源的压缩算法，目标不是最大化压缩比例或者与其他压缩库的兼容性，而是压缩速度和合理的压缩比例。例如与zlib的最快模式相比，Snappy对于大多数输入都会快一个量级，但生成的压缩文件会大20%到100%。</p><p>snappy算法基于LZ77进行优化，因为LZ77的匹配过程时间复杂度太高。</p><p>具体可以参考 <a href="https://zzjw.cc/post/snappy/#snappy">https://zzjw.cc/post/snappy/#snappy</a></p><h2 id="Gzip压缩算法原理"><a href="#Gzip压缩算法原理" class="headerlink" title="Gzip压缩算法原理"></a>Gzip压缩算法原理</h2>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zipline论文笔记</title>
    <link href="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="研究问题-amp-动机"><a href="#研究问题-amp-动机" class="headerlink" title="研究问题&amp;动机"></a>研究问题&amp;动机</h2><p>将开销较大的压缩和解压offload到可编程交换机（line rate），实现的压缩算法是generalized deduplication。</p><p>现有一些工作会在交换机上对数据流做on-the-fly的压缩（），但是方法是在第三层及以上，Zipline是在layer2进行压缩，可以支持更广泛的传输协议。</p><p>IoT应用一般需要处理小数据块并且因为内存限制，需要对小数据块进行压缩。标准的压缩算法对小数据块的表现不够好，而GD对小数据块的压缩表现也很好。因此对于live vedio streaming，如果deflate这种算法需要足够量的数据才能有较好的性能，但是攒这么多数据需要时间，影响实时性。这种情况下选择GD更好。</p><h2 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h2><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/compression.png" class="" title="图片引用方法一"><p>上图给出了压缩过程。</p><ol><li><p>接收到一个网络报文，包含数据payload B，长度为n个比特</p></li><li><p>使用Hamming decoder（会映射到Tofino内置的CRC模块，计算出来的结果是相同的）计算出一个m个比特长度的syndrome</p></li><li><p>用计算出的syndrome查表，得到一个对应长度为n的mask f</p></li><li><p>用查出的f与原本的数据按位异或，得到新的长度为n的b’</p></li><li><p>取b’最右的k位形成basis m</p></li><li><p>用m查basis-ID的表，看计算出来的basis是不是已经有一个更短的ID可以替换（从而达到压缩的目的）</p></li><li><p>如果表中用basis m能得到一个更短的ID，将包变成ID+syndrome；如果表中查不到对应的basis m，将包变成basis+syndrome</p></li></ol><p>（一开始不是很了解syndrome，参考了 <a href="https://www.youtube.com/watch?v=z89uW4eCRx0">https://www.youtube.com/watch?v=z89uW4eCRx0</a> 这个视频。）</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/decompression.png" class="" title="图片引用方法一"><p>同样，类似给出解压过程。</p><ol><li><p>接收到一个压缩后的网络报文（如果收到的包不是压缩的，即是basis+syndrome的类型，直接从步骤3开始），包含一个长度为t的ID和长度为m的syndrome</p></li><li><p>接收方也要有一个ID-basis表，与压缩方需要是一致的</p></li><li><p>查出对应的basis并且zero pad到原来的长度n比特（m+k&#x3D;n）</p></li><li><p>将n比特的pad后的basis输入CRC generator，得到长度m比特的parity bits p（得到之前truncated的数据）</p></li><li><p>根据收到的syndrome查表，得到对应长度为n的mask f。</p></li><li><p>用parity和basis组成长度为n的串，与f进行按位异或</p></li><li><p>得到原始数据b</p></li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>定义了三种类型的包：</p><ul><li>regular但unprocessed</li><li>processed但uncompressed</li><li>processed且compressed</li></ul><p>第一种可以是交换机收到的任意Ethernet包，并且将1作为输入，后续会转化成2或者3（如果计算出的basis有对应的更短ID）。</p><p>ID有限，但basis会有很多，所以使用<strong>LRU的回收机制</strong>。</p><p>syndrome look up table是一个match action table，里面的表项都是预先计算好并且不会改变的。</p><p>一种为basis选择对应ID的方法是使用cryptographic hash，但是密码散列函数在P4交换机上没有办法一轮完成。所以让控制平面来管理id的分配，当basis查表不存在时，通过digests发送到控制面，如果还有未使用的id，直接分配给该basis；如果id都使用了，通过LRU回收最近没有使用的ID。（如何保证还能正常解压？）TNA可以对表项添加ttl。需要先给目的交换机增加反过来的ID-basis表项，然后再给源交换机添加basis-ID表项。</p><p>实现的时候还需要考虑Tofino具体架构的限制，因为Tofino是为了对header自定义处理和routing而设计的，所以需要考虑到如下几个问题。</p><ul><li>Tofino架构中要求header必须是字节对齐的，但Hamming Code并不是字节对齐的，需要我们进行zero padding，并且会导致参数可以选择的范围减少（？）</li><li>论文最初的设计是将尽可能多的代码都放在数据面处理，所以考虑使用register进行存储。虽然这样能实现line rate，但是因为P4 pipeline中不支持loop，所以如果想要查看完整的register存储内容是无法实现的。因此将这些放到MATable中，通过控制平面来管理。这样的好处还有可以利用TNA提供的digests和per-table-entry TTL，能够更简单的实现LRU机制。唯一的缺点是因为涉及到了controller，更新会需要更多的时间。</li><li>ingress实现压缩，egress实现解压（编译器可以跨stage存表，可以将egress表放到还有空间的ingress stage中）</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><p>实验可以设置的参数包括Hamming Code中的k、n和m，但是因为k和n的取值都是与m相关的，所以实际只有m可以自由选择。又考虑到对字节对齐的限制，m必须是8的倍数才可以避免无用的padding。m选择为8，这是m能够选择的最大值，同时满足倍数限制且符合硬件限制。</p><p>考虑缓存的basis大小，这个参数选择同样也要考虑到字节对齐的因素（？）。因为需要留一个位存储MSB，所以满足硬件限制且不需要padding的最大值是15比特，因此缓存的basis大小为2^15 &#x3D; 32768。</p><h3 id="动态学习时间"><a href="#动态学习时间" class="headerlink" title="动态学习时间"></a>动态学习时间</h3><p>实验想要评估通过控制面管理basis-ID table对性能的影响，通过交换机接收一个未知basis到这个basis注册完能够在表中查到的时间间隔来衡量。尽可能快的发送相同数据包，然后在目的交换机上计算收到第一个类型2的包和收到第一个类型3的包之间的时间间隔。实验结果表明整个时间大概在1.77ms左右。</p><h3 id="压缩比例"><a href="#压缩比例" class="headerlink" title="压缩比例"></a>压缩比例</h3><p>数据集包括synthetic（类似一个传感器的typical readout）和real world（大学中一天的DNS请求）。</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/real_comp_ratio.png" class="" title="图片引用方法一"><p>实验有三种case：</p><ul><li><p>empty table 相当于是baseline</p></li><li><p>static table 预先计算好对应的basis以及ID</p></li><li><p>dynamic learning table开始是空的，随着不断注册增加表项</p></li><li><p>Gzip 单独将数据提取到一个文件中，并用gzip进行压缩</p></li></ul><p>空表的3% overhead是由padding导致的。static table是理想的情况，每个basis都事先预知id；dynamic learning是实际应用的情况。用实际常用的压缩算法gzip（在交换机上肯定无法实现！）进行比较，发现性能也挺好。</p><h3 id="raw-performance"><a href="#raw-performance" class="headerlink" title="raw performance"></a>raw performance</h3><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/compression_ratio.png" class="" title="图片引用方法一"><p>发送Ethernet数据包，分为三种大小，64B、1500B以及9KB。</p><p>server不断给自己发送包，通过测量ttl计算延时。</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/latency.png" class="" title="图片引用方法一"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想要在P4上做压缩算法，常见的压缩算法应该不太适用（比如snappy、gzip这种），因为pipeline不支持循环，因此匹配相同的子串难以实现。所以需要找一些其他的压缩算法，比如这一篇用的GD就能正好利用Tofino的内置CRC模块，并且最终实现的效果与gzip相差并不太大。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>P4可编程交换机</tag>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
