<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Data无损压缩</title>
    <link href="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/"/>
    <url>/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h2 id="研究问题-amp-动机"><a href="#研究问题-amp-动机" class="headerlink" title="研究问题&amp;动机"></a>研究问题&amp;动机</h2><p>传统的data deduplication是对整个数据块进行去重，而去重需要两个数据块完全相同，才能认为有相同的base。但对于time series data（论文中举的例子是传感器检测温度的数据）来说，相邻的数据块可能会非常相似，但是因为不是完全相同，所以没有办法去重（现有的研究也有提出一种multi-step的方法，即当出现第一个重复的chunk，除了去重之外，还要遍历一遍查找相似的chunk，再进行delta compression）。因此提出的压缩算法适合压缩相似但不完全相同的时序数据。</p><p>通用的基于LZ的压缩算法不适合大规模数据，因为他们的窗口比较小，并且没有办法考虑全局的数据。因此在这种基础上，为大规模数据提出了data deduplication的概念。</p><h2 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h2><p>整个压缩的主要逻辑就是要将chunk分成两部分，一部分是basis（用于deduplication），另一部分是deviation（直接存储不进行压缩）。</p><p>如果选择deviation的长度为2个字节，那么可以对2^16 &#x3D; 65536个相似的数据块进行去重。</p><p>假设一共有c个chunk，不妨分别记为z<sub>1</sub>, z<sub>2</sub>,…,z<sub>c</sub>。并且每一个chunk的长度都是n比特。压缩算法会把每一个chunk z<sub>i</sub>分割成两个部分，一个是长度为k的base x<sub>i</sub>，另一个是长度为m的deviation y<sub>i</sub>。</p><p>但是在压缩之前会先进行一个移位的操作，因为在time series data中，通常会有一些bits跟其余部分的关联性很低（比如LSB的数据很难根据MSB的数据进行推测，这两个关联性不大）。想要实现的是尽可能的分成两个关联性低的部分。</p><p>为了定量的精确衡量这种关联性的大小，使用两个随机变量的互信息来定义：</p><p>$$I(x,y) &#x3D; H(x) + H(Y) - H(X, Y)$$</p><p>如果假设deviation的长度m是已知的，J是对应deviation的下标集合，那么移位的操作希望最小化H(Z<sub>J</sub>, Z<sub>J<sup>C</sup></sub>)的互信息取值。</p><p>当chunk很大的时候，一一枚举开销非常大，使用贪心算法进行m次迭代：</p><img src="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/greedy.png" class="" title="图片引用方法一"><p>（或者也可以设置停止条件，但是可能迭代次数会更多？）</p><p>这样的压缩算法可以保证稳定性（某些chunk损坏不会影响剩下其他chunk的压缩和解压）和对数据的即时存储、搜索和查找。</p><p><strong>重点：估计过程只需要用training set做一次！可以开始的时候系统先不压缩，收集一定量的数据完成估计过程，确定J的下标集合</strong></p><p>因为还需要解压，所以还需要对J进行存储。因为J中的内容是m个取值范围不会超过n的整数，所以可以用Elias gamma code进行编码。这样编码之后需要的空间不会超过$m(2logn+1)$。</p><p>压缩过程需要一个deduplication dictionary（初始是一个空词典），用来存储已经出现过的base。</p><img src="/2022/11/12/Data%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9/dict.png" class="" title="图片引用方法一"><p>如果已经出现，换成对应id+deviation。</p><h2 id="压缩性能"><a href="#压缩性能" class="headerlink" title="压缩性能"></a>压缩性能</h2><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这个压缩算法的最明显的好处是每一个chunk只需要一次pass就可以压缩完成，并且需要移位的下标信息可以预训练获得，可以使用多次。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode合集</title>
    <link href="/2022/11/11/LeetCode%E5%90%88%E9%9B%86/"/>
    <url>/2022/11/11/LeetCode%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode1704-判断字符串两段是否相等"><a href="#LeetCode1704-判断字符串两段是否相等" class="headerlink" title="LeetCode1704 判断字符串两段是否相等"></a>LeetCode1704 判断字符串两段是否相等</h2><p>题目整体没有什么难度，使用了最简单的得到两个子串后分别计数并比较是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">halvesAreAlike</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> &#123;<br>        <span class="hljs-type">int</span> length = s.length();<br>        <span class="hljs-built_in">string</span> firstHalfStr = s.substr(<span class="hljs-number">0</span>, length / <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">string</span> SecondHalfStr = s.substr(length / <span class="hljs-number">2</span>, length / <span class="hljs-number">2</span>);<br><br>        <span class="hljs-keyword">if</span>(isTwoStrSame(firstHalfStr, SecondHalfStr)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>private:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isTwoStrSame</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span> &#123;<br>        <span class="hljs-type">int</span> num1 = getNum(str1);<br>        <span class="hljs-type">int</span> num2 = getNum(str2);<br><br>        <span class="hljs-keyword">if</span>(num1 == num2) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getNum</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1)</span> &#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> len = str1.length();<br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; len;i++) &#123;<br>            <span class="hljs-keyword">if</span>(str1[i] == <span class="hljs-string">&#x27;a&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;A&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;e&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;E&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;i&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;I&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;o&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;O&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;u&#x27;</span> || str1[i] == <span class="hljs-string">&#x27;U&#x27;</span>) &#123;<br>                num += <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这样开销比较大，看题解发现还可以使用双指针或者使用位运算。</p><h2 id="LeetCode202-快乐数"><a href="#LeetCode202-快乐数" class="headerlink" title="LeetCode202 快乐数"></a>LeetCode202 快乐数</h2><p>题目整体比较简单，核心思路大致为需要使用一个set保存已经出现过的平方和取值，每次计算时候需要在集合中进行查找，如果搜索到中止，如果没有搜索到将这个值加入集合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>public:<br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">set</span>&lt;<span class="hljs-type">int</span>&gt; all_sum_results;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> current_value = n;<br>        <span class="hljs-type">int</span> current_value_sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(!flag) &#123;<br>            current_value_sum = getSum(current_value);<br>            current_value = current_value_sum;<br><br>            <span class="hljs-keyword">if</span>(current_value_sum == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(all_sum_results.find(current_value_sum) != all_sum_results.end()) &#123;<br>                <span class="hljs-comment">//already exists! loop occurred</span><br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                all_sum_results.insert(current_value_sum);<br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>private:<br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> current_value)</span> &#123;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; num_bits;<br>    <span class="hljs-type">int</span> sum_value = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(current_value) &#123;<br>        sum_value += (current_value % <span class="hljs-number">10</span>) * (current_value % <span class="hljs-number">10</span>);<br>        current_value /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum_value;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他解题思路使用<strong>快慢指针</strong>来找出循环，非常巧妙，避免当set太大的时候存储开销过大。（循环的时候判断此时取值是否为1，如果是1说明是快乐数，如果不是1说明出现loop）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">bool</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> slow = n, fast = n;<br>        <span class="hljs-keyword">do</span>&#123;<br>            slow = bitSquareSum(slow);<br>            fast = bitSquareSum(fast);<br>            fast = bitSquareSum(fast);<br>        &#125;<span class="hljs-keyword">while</span>(slow != fast);<br>        <br>        <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>浅浅刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库常用压缩算法比较</title>
    <link href="/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/"/>
    <url>/2022/11/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="比较不同压缩算法trade-off"><a href="#比较不同压缩算法trade-off" class="headerlink" title="比较不同压缩算法trade off"></a>比较不同压缩算法trade off</h2><p>压缩的本质是减少IO操作，从而带来更快的读写操作。需要用CPU周期来对IO性能进行tradeoff。</p><p>但是同时还要考虑到实际应用的性能需求，如实时性、吞吐等。不同压缩算法的cost不同，因此需要综合考虑。</p><h2 id="评估压缩算法的指标"><a href="#评估压缩算法的指标" class="headerlink" title="评估压缩算法的指标"></a>评估压缩算法的指标</h2><ul><li>压缩比 compression ratio</li><li>吞吐 throughput</li><li>压缩速度 compression speed</li><li>解压速度 decompression speed</li><li>内存 memory</li></ul><p>图中给出的是java-based benchmarking，重点比较gzip和snappy两种最通用的算法。</p><p>绿色的指标是compression ratio，越小越好；黄色的指标是throughput，越大越好。</p><p>gzip的压缩比例优于snappy，但snappy的吞吐高于gzip。</p><h2 id="如何选择适合的压缩算法"><a href="#如何选择适合的压缩算法" class="headerlink" title="如何选择适合的压缩算法"></a>如何选择适合的压缩算法</h2><ul><li>选择的压缩算法需要能够支持配置的big data environment（Spark、HIVE、presto、parquet、hadoop、S3、kafka等）</li><li>能够支持serialization format</li><li>考虑数据的生命周期以及访问模式！<br>（对于声明周期长但访问不频繁的cold data可以选择gzip压缩算法，频繁访问的hot data可以选择snappy压缩算法）</li><li>key wordload&amp;split-ability<br>（比如gzip就是不能支持split的数据，所以如果使用hadoop这种map reduce的应用，不选用gzip压缩算法）</li></ul><h2 id="Snappy压缩算法原理"><a href="#Snappy压缩算法原理" class="headerlink" title="Snappy压缩算法原理"></a>Snappy压缩算法原理</h2><p>snappy（又称zippy）是google开源的压缩算法，目标不是最大化压缩比例或者与其他压缩库的兼容性，而是压缩速度和合理的压缩比例。例如与zlib的最快模式相比，Snappy对于大多数输入都会快一个量级，但生成的压缩文件会大20%到100%。</p><p>snappy算法基于LZ77进行优化，因为LZ77的匹配过程时间复杂度太高。</p><p>具体可以参考 <a href="https://zzjw.cc/post/snappy/#snappy">https://zzjw.cc/post/snappy/#snappy</a></p><h2 id="Gzip压缩算法原理"><a href="#Gzip压缩算法原理" class="headerlink" title="Gzip压缩算法原理"></a>Gzip压缩算法原理</h2>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zipline论文笔记</title>
    <link href="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="研究问题-amp-动机"><a href="#研究问题-amp-动机" class="headerlink" title="研究问题&amp;动机"></a>研究问题&amp;动机</h2><p>将开销较大的压缩和解压offload到可编程交换机（line rate），实现的压缩算法是generalized deduplication。</p><p>现有一些工作会在交换机上对数据流做on-the-fly的压缩（），但是方法是在第三层及以上，Zipline是在layer2进行压缩，可以支持更广泛的传输协议。</p><p>IoT应用一般需要处理小数据块并且因为内存限制，需要对小数据块进行压缩。标准的压缩算法对小数据块的表现不够好，而GD对小数据块的压缩表现也很好。因此对于live vedio streaming，如果deflate这种算法需要足够量的数据才能有较好的性能，但是攒这么多数据需要时间，影响实时性。这种情况下选择GD更好。</p><h2 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h2><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/compression.png" class="" title="图片引用方法一"><p>上图给出了压缩过程。</p><ol><li><p>接收到一个网络报文，包含数据payload B，长度为n个比特</p></li><li><p>使用Hamming decoder（会映射到Tofino内置的CRC模块，计算出来的结果是相同的）计算出一个m个比特长度的syndrome</p></li><li><p>用计算出的syndrome查表，得到一个对应长度为n的mask f</p></li><li><p>用查出的f与原本的数据按位异或，得到新的长度为n的b’</p></li><li><p>取b’最右的k位形成basis m</p></li><li><p>用m查basis-ID的表，看计算出来的basis是不是已经有一个更短的ID可以替换（从而达到压缩的目的）</p></li><li><p>如果表中用basis m能得到一个更短的ID，将包变成ID+syndrome；如果表中查不到对应的basis m，将包变成basis+syndrome</p></li></ol><p>（一开始不是很了解syndrome，参考了 <a href="https://www.youtube.com/watch?v=z89uW4eCRx0">https://www.youtube.com/watch?v=z89uW4eCRx0</a> 这个视频。）</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/decompression.png" class="" title="图片引用方法一"><p>同样，类似给出解压过程。</p><ol><li><p>接收到一个压缩后的网络报文（如果收到的包不是压缩的，即是basis+syndrome的类型，直接从步骤3开始），包含一个长度为t的ID和长度为m的syndrome</p></li><li><p>接收方也要有一个ID-basis表，与压缩方需要是一致的</p></li><li><p>查出对应的basis并且zero pad到原来的长度n比特（m+k&#x3D;n）</p></li><li><p>将n比特的pad后的basis输入CRC generator，得到长度m比特的parity bits p（得到之前truncated的数据）</p></li><li><p>根据收到的syndrome查表，得到对应长度为n的mask f。</p></li><li><p>用parity和basis组成长度为n的串，与f进行按位异或</p></li><li><p>得到原始数据b</p></li></ol><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>定义了三种类型的包：</p><ul><li>regular但unprocessed</li><li>processed但uncompressed</li><li>processed且compressed</li></ul><p>第一种可以是交换机收到的任意Ethernet包，并且将1作为输入，后续会转化成2或者3（如果计算出的basis有对应的更短ID）。</p><p>ID有限，但basis会有很多，所以使用<strong>LRU的回收机制</strong>。</p><p>syndrome look up table是一个match action table，里面的表项都是预先计算好并且不会改变的。</p><p>一种为basis选择对应ID的方法是使用cryptographic hash，但是密码散列函数在P4交换机上没有办法一轮完成。所以让控制平面来管理id的分配，当basis查表不存在时，通过digests发送到控制面，如果还有未使用的id，直接分配给该basis；如果id都使用了，通过LRU回收最近没有使用的ID。（如何保证还能正常解压？）TNA可以对表项添加ttl。需要先给目的交换机增加反过来的ID-basis表项，然后再给源交换机添加basis-ID表项。</p><p>实现的时候还需要考虑Tofino具体架构的限制，因为Tofino是为了对header自定义处理和routing而设计的，所以需要考虑到如下几个问题。</p><ul><li>Tofino架构中要求header必须是字节对齐的，但Hamming Code并不是字节对齐的，需要我们进行zero padding，并且会导致参数可以选择的范围减少（？）</li><li>论文最初的设计是将尽可能多的代码都放在数据面处理，所以考虑使用register进行存储。虽然这样能实现line rate，但是因为P4 pipeline中不支持loop，所以如果想要查看完整的register存储内容是无法实现的。因此将这些放到MATable中，通过控制平面来管理。这样的好处还有可以利用TNA提供的digests和per-table-entry TTL，能够更简单的实现LRU机制。唯一的缺点是因为涉及到了controller，更新会需要更多的时间。</li><li>ingress实现压缩，egress实现解压（编译器可以跨stage存表，可以将egress表放到还有空间的ingress stage中）</li></ul><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h3><p>实验可以设置的参数包括Hamming Code中的k、n和m，但是因为k和n的取值都是与m相关的，所以实际只有m可以自由选择。又考虑到对字节对齐的限制，m必须是8的倍数才可以避免无用的padding。m选择为8，这是m能够选择的最大值，同时满足倍数限制且符合硬件限制。</p><p>考虑缓存的basis大小，这个参数选择同样也要考虑到字节对齐的因素（？）。因为需要留一个位存储MSB，所以满足硬件限制且不需要padding的最大值是15比特，因此缓存的basis大小为2^15 &#x3D; 32768。</p><h3 id="动态学习时间"><a href="#动态学习时间" class="headerlink" title="动态学习时间"></a>动态学习时间</h3><p>实验想要评估通过控制面管理basis-ID table对性能的影响，通过交换机接收一个未知basis到这个basis注册完能够在表中查到的时间间隔来衡量。尽可能快的发送相同数据包，然后在目的交换机上计算收到第一个类型2的包和收到第一个类型3的包之间的时间间隔。实验结果表明整个时间大概在1.77ms左右。</p><h3 id="压缩比例"><a href="#压缩比例" class="headerlink" title="压缩比例"></a>压缩比例</h3><p>数据集包括synthetic（类似一个传感器的typical readout）和real world（大学中一天的DNS请求）。</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/real_comp_ratio.png" class="" title="图片引用方法一"><p>实验有三种case：</p><ul><li><p>empty table 相当于是baseline</p></li><li><p>static table 预先计算好对应的basis以及ID</p></li><li><p>dynamic learning table开始是空的，随着不断注册增加表项</p></li><li><p>Gzip 单独将数据提取到一个文件中，并用gzip进行压缩</p></li></ul><p>空表的3% overhead是由padding导致的。static table是理想的情况，每个basis都事先预知id；dynamic learning是实际应用的情况。用实际常用的压缩算法gzip（在交换机上肯定无法实现！）进行比较，发现性能也挺好。</p><h3 id="raw-performance"><a href="#raw-performance" class="headerlink" title="raw performance"></a>raw performance</h3><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/compression_ratio.png" class="" title="图片引用方法一"><p>发送Ethernet数据包，分为三种大小，64B、1500B以及9KB。</p><p>server不断给自己发送包，通过测量ttl计算延时。</p><img src="/2022/11/08/Zipline%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/latency.png" class="" title="图片引用方法一"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果想要在P4上做压缩算法，常见的压缩算法应该不太适用（比如snappy、gzip这种），因为pipeline不支持循环，因此匹配相同的子串难以实现。所以需要找一些其他的压缩算法，比如这一篇用的GD就能正好利用Tofino的内置CRC模块，并且最终实现的效果与gzip相差并不太大。</p>]]></content>
    
    
    <categories>
      
      <category>科研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>P4可编程交换机</tag>
      
      <tag>压缩算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
